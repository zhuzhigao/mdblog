<!--
title: 大数据日知录 - 分布式通讯
date: 2017-01-05 15:32:49
tags:
- Big Data
- Distributed Communication
- Kafka
- RabbitMQ
-->
### 大数据日知录 - 分布式通讯
Date: 2017-01-05 15:32:49
三种常用通信机制：
- 序列化与远程过程调用
- 消息队列
- 多播通信
<!-- more -->
## 序列化与远程过程调用
RPC框架一般融合数据序列化与反序列化。通用序列化与RPC框架通常支持IDL, 高性能，数据版本支持及二进制数据格式。
- Protocal Buffer是Google内部使用的RPC框架，数据压缩率高。
- Thrift是Facebook开源的序列化与RPC框架，支持的数据类型比PB多。两者都通过IDL定义消息体和RPC函数调用接口。
- Apache Avro使用JSON作为IDL定义语言，可以灵活定义数据Schema及RPC通讯协议，并能跟动态语言集成。数据可以为二进制或者JSON. Schema独立于数据并在序列化时置于数据之首，便于动态语言集成。

## 消息队列
常见消息队列有:
- ActiveMQ, 6K TPS (Trasaction Per Second)，相对重量级
- ZeroMQ， 100k TPS，最轻量级，不支持消息持久化
- Kafka, 40k TPS， 轻量级，支持消息持久化和“至少送达一次”
- RabbitMQ, 10K TPS，相对重量级

两种模式：
- 消息队列模式， 生产者存储消息入队列，消费者从队列里消费消息
- Pub-Sub模式，消费者订阅指定主题的消息队列，当主题有新消息是，可以通过push或者pull将消息消费掉。
大多数消息中间件支持消息持久化存储(ZeroMQ除外）。

### Kafka
Linkedin 开源的Pub-Sub消息队列。
Kafka消费者通过pull来赌气消息，利于自助控制消费速率，但容易导致消息积压。

消息被切换为多个有序分片，消息生产者可以根据一定的逻辑制定数据分片，便于后续处理。数据分片被切割成固定大小文件，产生新消息是，追加到文件尾部。内存维护每个文件首个消息Offset组成的有序数组作为索引。读取消息是根据索引二分查找到对应的消息文件及消息内容在文件中的起始位置。
![image](http://static.oschina.net/uploads/space/2016/0509/211717_nQ5s_119760.jpg)
除了消费者读到了哪个信息，Kafka使用Zookeeper来管理很多状态信息，使得消息代理服务器是无状态的。

Kafka使用副本来提供高可用消息服务。副本服务器是主服务器的数据消费者。所有消息都由主服务器响应。 Kafka使用ISR来保证一致性，如果ISR集合大小为f+1，则最多允许f个副本失效，其中只有1副本余主副本实时保持一致，其他f个部分允许延迟。

## 应用层多播通信
将数据如何通知到网络中的多个接收方

### Gossip协议
多种应用与状态交换相关的应用，如Cassandra的故障检测，集群管理和副本数据修复，BitTorrent的节点信息交换，数据的最终一致性和负载均衡的。

- 全部通知模型，通知所有其他节点，并根据消息新旧更新
- 反熵模型。P随机选择一个节点Q,与Q交换信息。如果Q有更新，则类似P一样传播给人以其他节点。
    - Push，开始快，又来慢
    - Pull，开始慢，后来快，总体好于Push.
    - Push-Pull,双方同时互相通知对方更新，效率最高
- 谣言模式
    - 每次通知Q如果Q已经被更新，则P增加其不通知其他节点的概率。保证左右节点得到更新。

Cassandra - P2P列式数据库集群采用Gossip的反熵模式来委屈节点状态。A(最新状态)->B（B比A新的状态）->A（更新状态，发送B需要更新的状态）->B（更新状态）
